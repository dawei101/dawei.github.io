---
id: 67
title: socket工作原理!
date: 2011-04-14T00:18:00+00:00
author: dawei
layout: post
guid: http://bookwikiup.com/blog/?p=67
permalink: /2011/04/14/socket%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86/
categories:
  - 未分类
---
使用sockets Socket控件让你建立一个利用TCP/IP和有关的协议与其他系统进行通信的应用。使用Sockets,你能够读和写通过它连接的其他机器，而不用担心实际的网络软件的相关细节。Sockets提供基于TCP/IP协议的连接。除此以外还能很好的工作，在其他相关的协议，例如Xerox Network System (XNS), Digital’s DEC net, or Novell’s IPX/SPX 家族。   
C++ Builder提供你写网络服务器或客户应用程序去读和写其他的系统。一个服务或客户程序通常专注于一个单一的服务如超文本传送协议（HTTP)或文件传输协议(FTP)。使用server sockets,一个应用程序可以提供这些服务中的一个去连接一个希望使用服务的客户程序。Client sockets允许一个应用使用这些服务中的一个去连接提供这个服务的服务应用。

使用sockets去写应用程序，你必须理解下面这些知识：  
一、服务工具   
当你需要写网络服务或客户应用时，Sockets提供一种接合。对于许多服务，象HTTP 或 FTP,第三方服务商提供这些服务已经相当有效。有些甚至随着操作系统捆绑而来，以便不用你自己写。然而，当你想更多的控制服务的实现，如想让你的应用程序与网络通信更加紧密，或当没有一个服务能提供你特殊需要的服务时，你可能想建立你自己的服务或客户应用。例如，工作在分布式data sets时，你可能想为数据库写一层与其他系统通信的应用。想使用Sockets实现一个服务，你必须理解：  
1.服务协议  
在你写一个网络服务或客户程序前，你必须明白你的应用将提供或使用什么服务。你的网络应用必须支持许多服务的标准协议。如果你为标准的服务例如HTTP,FTP写网络应用，或even finger or time,你必须先理解与其他系统通信所使用的协议。特殊服务细节你必须看提供的或使用的文档。如果你的应用程序提供一个新的服务与其他系统通信，第一步是为这个服务的服务端和客户端设计通信协议。什么信息将发送？如何整理这些信息？如何对这些信息进行编码？  
应用程序通信  
经常的，你的网络服务端或客户端应用程序要提供一层在网络软件和一个应用之间使用的服务。例如，一个HTTP服务站点在INternet与一个Web 服务应用之间为HTTP请求信息提供内容和应答。  
在你的网络应用（或客户应用）和网络软件之间Sockets 提供一个接口。你必须提供一个接口，在你的应用程序与应用间使用。你可以拷贝第三方服务商提供的标准API(例如ISAPI），或你可以设计和发布你自己的API.  
2.理解服务和端口  
许多标准服务都有关联的、指定的端口号。当 执行服务时，你可以为服务考虑一个端口号。如果你实现一个标准服务， Windows socket objects 提供一些方法让你为服务寻找端口号。如果提供一个新的服务，在基于Windows 95 或 NT机器上，你能够在文件Services中为你的服务指定一个相关联的端口号。设置Services文件的更多信息请看微软 的Windows Sockets文档。  
二、Socket连接的类型  
Socket连接可以分成三个基本的类型，它们反映了如何开始连接和本地Socket 连接是什么。这三个类型是：  
1.客户端连接   
客户端连接是一个本地系统的客户端socket与一个远程系统上的服务端Socket连接。客户端连接由客户端Socket开始。首先，客户端 Socket必须描述它想连接到的服务端Socket. 接着客户端socket查找服务端socket，当找到服务器时，就要求连接。服务端socket可能不能完成正确的连接。服务器sockets维持一个客户端请求队列，在他们有时间时完成连接。当服务端socket接受客户端连接，服务端socket  
将向它想连接的客户socket发送一个完整的描述，客户端的连接完成。  
2.倾听连接   
服务器 socket不会去定位客户端，代替的，他们形成被动的，"半连接"状态，倾听来自客户端的请求。服务器 sockets形成一个队列，存放 它们听到的连接请求。这个队列记录着客户端连接请求就象他们已连接进来一样。当服务器sockets同意客户连接请求时，它形成一个新的socket去连接客户端，因此这个倾听连接能保持开放状态允许其他客户端请求。  
3.服务端连接   
当倾听socket同意一个客户端请求时，服务器端socket形成一个服务器连接。当服务器端同意连接时，向客户端发送一个服务端socket描述以完成连接，当客户端socket收到这个描述时这个连接得到确认，连接完成。一但连接到客户端的Socket完成，服务端连接就不能识别从一个客户端来的连接。末端双方有同样的能力去接收同样的事件类型。只有倾听（listening)连接是根本不同的，它只有一个单一的末端。  
三、sockets描述   
Sockets让你的网络应用软件通过网络与其他系统进行通信。在网络连接中每个socket可以看成一个终端点。它有一个指定的地址。  
*这个系统正在运行  
*它理解的接口类型  
*用来连接的端口  
一个完整的socket连接描述，你必须提供sockets 在连接两端的地址。在你开始一个socket连接前，你必须完整的描述你想得到的连接。有些信息可以从你的应用  
软件运行的系统平台上得到。例如，你不需要描述一个客户端socket的本地IP地址–这个信息可以从操作系统上获得。你必须提供你工作所依靠的 socket的类型的信息。客户端socket必须描述他们想连接的服务器。侦听服务器sockets必须描述他们提供反应的服务器的端口。一个 socket 连接终端的完整描述包括两部分：  
1.IP地址  
主机是这样一个系统，它运行着包含有socket的应用程序。你必须描述主机给socket，通过给出主机的IP地址来完成这个描述。IP地址是一个有四个数字（byte)值的，在标准internet点付内的字符串。  
例如123.197.1.2  
一个简单的系统可以支持多于一个的IP地址。IP地址通常难于记忆并且容易打错。一个可供选择的方法是使用主机名。主机名就是IP地址的别名，它就是你常看到的统一资源定位（URLs)。它是一个字符串，包括了域名和服务。  
例如 http://www.wsite.com  
许多内部网提供给主机的名字对应的系统IP地址是internetIP地址。在windows95 和NT机器上，如果一个主机名不能用，你可以在HOSTS文件中为你的本地IP地址（这个本地IP地址应该是指你想连接的主机IP地址–zyqsj)建立一个进入的名字。  
关于HOSTS文件的更多信息请看WINDOWS SOCKETS的文档。  
服务器sockets不需要指定主机。本地IP地址可以从系统中读到。如果本地系统支持多于一个的IP地址，服务器sockets将同时在所有的IP地址上侦听客户端请求。当一个服务器socket同意一个连接，客户端提供一个远程IP地址。客户sockets必须指定远程主机通过提供主机名或者IP地址。  
在主机名和IP地址间作一个选择  
许多应用软件使用一个主机名去指定一个系统。主机名容易记住和容易检查排版错误。进一步讲，服务器能改变系统或与IP地址关联的特殊的主机名。使用一个主机名，能够允许客户端通过主机名描述找到抽象的站点，即使主机使用一个新的IP地址。  
如果主机名是未知的，客户socket必须指定服务器系统使用的IP地址。通过给一个IP地址来指定服务器将更快。当你提供主机名时，socket在定位服务器系统前，必须搜寻与这个主机名相关的IP地址。  
2.端口号  
虽然IP得地址提供了足够的信息去找到socket连接中位于另一端的系统，你通常还需要指定那个系统的端口号。没有端口号，一个系统在同一时间只能进行一个单一的连接。端口号是唯一标识那允许一个独立系统连接到支持同时多个连接的主机，每个连接都必须指定一个端口号。  
在网络应用中，对于服务器工具来说端口号是一个数字代码。有一个习惯就是侦听服务连接到他们自己固定的端口号上，以便他们能找到客户端sockets.服务器socket监听为他们提供服务的相关端口号。当他们允许给予一个客户端socket连接时，他们创建一个独立的socket连接，使用不同的专用的端口号。通过这个方法，能持续的监听相关服务的端口号。  
客户端socket使用一个专用的本地端口号，就不用其他的socket去寻找它们。他们指定他们想连接的服务器端socket的端口号，这样他们就能找到服务器应用程序。常常的，这个端口号是通过命名想连接的服务来间接指定的。  
四、使用socket控件  
C++Builder提供两个socket控件，客户端sockets和服务器sockets.他们允许你的网络应用构成连接其他的机器和允许你通过这个连接来读写信息。与每个socket控件相关联的是windows socket对象，它们在终端的的作用是一个实际的socket连接。socket控件使用windows socket对象去封装windows socket API 调用，所以你的应用不用去关心连接建立的细节或管理socket信息。  
如果你想利用windows socket API调用或自定义连接细节，socket控件提供了便利，你可以使用windows socket对象的properies,events和方法。  
1.使用客户端sockets  
添加一个客户端socket控件（TClientSocket)到你的form或data module 使你的应用成为一个TCP/IP客户。客户sockets允许你指定你想连接的服务器socket和你希望服务器提供的服务。一但你描述你想得到的连接，你可以使用客户socket控件去完成连接服务。  
每个客户socket控件使用独立的客户windows socket对象(TClientWinSocket)去应答连接中的客户终端。使用客户sockets去：  
A.指定想得到的服务  
客户socket控件有一个数字properties,允许你指定想连接的服务器系统和端口。你可以通过主机名来指定服务器系统，使用Host property。  
如果你不知道主机名，或者你关心找到服务器的速度，你可以指定服务器系统的IP地址，通过使用 Address property。你必须指定IP地址和主机名中的一个。  
如果你两个都指定，客户socket控件将使用主机名。除服务器系统外，你必须指定你的客户socket将连接的在服务器系统上的端口。你能够直接使用 Port property来指定服务端口号。或者直接在Service property使用想得到的服务的名字。如果你指定端口号和服务名，客户socket控件将使用服务名。  
B.建立连接  
一旦你在客户socket控件中完成了设置描述你想连接的服务器的属性，你就可以进行连接，通过调用Open方法。如果你想你的应用启动时自动建立连接，在设计时设置Active property为true，通过使用Object Inspector来设置。  
C.取得关于连接的信息  
完成连接到服务器socket后，你可以使用与你的客户socket控件相关的客户windows socket object去取得关于连接的信息。使用Socket property去访问client windows socket object。windows socket object 有一个properties,它能让你确定在连接的两端客户和服务器使用的地址和端口号。  
当使用一个windows socket API调用时，你可以使用SocketHandle property区获得socket连接使用的handle。你可以使用Handle property去访问windows,以便接收来自socket连接的信息。AsyncStyles property决定哪种信息类型是windows handle要接收的。  
D.关闭连接  
当你完成通讯想关闭socket 连接时，你能够通过调用Close方法来关闭连接。连接可能要由服务器端来关闭。如果是这种情况，你将收到一个OnDisconnect 事件的通知。  
2.使用服务器sockets  
添加一个服务端socket控件（TServerSocket)到你的form或data module使你的应用成为一个TCP/IP服务器。服务器sockets允许你指定你想提供的服务或你想用来监听客户请求时使用的端口。你可以使用服务器socket控件去监听和允许客户连接请求。每个服务器socket控件使用一个单一的服务器windows socket Object(TServerWinSocket)去应答在服务器端监听到的连接。它通常使用一个服务器客户winodws socket Object(TServerClientWinSocket)应答在服务器端每个活动的，连接着得到允许服务的客户socket。使用服务器 sockets去：  
A.指定端口  
在你的服务器socket能够监听客户请求之前，你必须指定一个端口给你的监听服务。你可以使用Port property来指定这个端口。如果你的服务器应用提供一个标准的服务，这个服务使用一个习惯使用的相关联的端口。你能够使用Service property直接指定端口号。使用Service property是一个好的主意，能够减少设置端口号时的错误。如果你既指定了Port property,又指定了Service property,服务socket将使用服务名。  
B.监听客户请求  
一旦你在server socket控件上设置好你的端口号，你就能够通过在运行时通过调用Open方法来监听一个连接。如果你希望你的应用程序能够在启动的时候自动监听连接，在设计的时候通过使用Object Inspector设置Active 属性为true。  
C.连接到客户端。  
当监听服务socket控件接收到一个客户端连接请求时他们将自动接受这个请求。当你没次收到通知时，OnClientConnetc事件将发生。  
D.取得  
C.取得关于连接的信息  
完成连接到服务器socket后，你可以使用与你的客户socket控件相关的客户windows socket object去取得关于连接的信息。使用Socket property去访问client windows socket object。windows socket object 有一个properties,它能让你确定在连接的两端客户和服务器使用的地址和端口号。  
当使用一个windows socket API调用时，你可以使用SocketHandle property区获得socket连接使用的handle。你可以使用Handle property去访问windows,以便接收来自socket连接的信息。AsyncStyles property决定哪种信息类型是windows handle要接收的。  
D.关闭连接  
当你完成通讯想关闭socket 连接时，你能够通过调用Close方法来关闭连接。连接可能要由服务器端来关闭。如果是这种情况，你将收到一个OnDisconnect 事件的通知。  
2.使用服务器sockets  
添加一个服务端socket控件（TServerSocket)到你的form或data module使你的应用成为一个TCP/IP服务器。服务器sockets允许你指定你想提供的服务或你想用来监听客户请求时使用的端口。你可以使用服务器socket控件去监听和允许客户连接请求。每个服务器socket控件使用一个单一的服务器windows socket Object(TServerWinSocket)去应答在服务器端监听到的连接。它通常使用一个服务器客户winodws socket Object(TServerClientWinSocket)应答在服务器端每个活动的，连接着得到允许服务的客户socket。使用服务器 sockets去：  
A.指定端口  
在你的服务器socket能够监听客户请求之前，你必须指定一个端口给你的监听服务。你可以使用Port property来指定这个端口。如果你的服务器应用提供一个标准的服务，这个服务使用一个习惯使用的相关联的端口。你能够使用Service property直接指定端口号。使用Service property是一个好的主意，能够减少设置端口号时的错误。如果你既指定了Port property,又指定了Service property,服务socket将使用服务名。  
B.监听客户请求  
一旦你在server socket控件上设置好你的端口号，你就能够通过在运行时通过调用Open方法来监听一个连接。如果你希望你的应用程序能够在启动的时候自动监听连接，在设计的时候通过使用Object Inspector设置Active 属性为true。  
C.连接到客户端。  
当监听服务socket控件接收到一个客户端连接请求时他们将自动接受这个请求。当你没次收到通知时，OnClientConnetc事件将发生。  
D.取得关于连接的信息  
一但你的服务器socket打开了监听连接，你能够使用与你服务器socket控件相关联的服务器windows socket object来取得关于连接的信息。使用Socket property去访问server windows socket object.windows socket object有一个属性能够让你找到关于所有活动的客户socket连接这些客户socket是你通过服务器socket控件允许连接的。使用 Handle属性去存取windows通过socket连接收到的信息。  
每个活动的，连接到客户应用是通过服务、客户windows socket bject (TServerClientWinSocket)封装的。你能够通过server windows socket object的连接属性来访问所有的这些。这些server client windows socket object有些属性让你能够决定哪些地址和端口号给连接的两端–客户和服务器socket使用。当你使用windows socket API调用时，可以使用SocketHandle属性去获得socket连接使用的handle。你能够使用Handle属性去访问windows从 socket连接处得来的信息。AsyncStyles属性决定windows handle将接收哪种类型的信息。  
E.关闭连接  
当你决定关闭监听连接时，调用Close方法。这将关闭所有打开着的，连接到客户应用的连接，取消任何尚未同意的连接，接着关闭监听连接以便你的服务socket控件不在接受任何新的连接。当客户端关闭他们自己独立的连接到你的server socket的连接时，你可以在OnClientDisconnect事件中得到讯息。  
五、socket事件的应答  
当使用sockets写应用程序时，大多数工作发生在socket控件的handler事件中.当通过 socket连接开始读或写时,OnRead和OnWrite事件在non-blocking client sockets中发生从而通知sockets.同样的,服务器sockets(blocking or non-blocking)收到OnClientRead和OnClientWrite事件.  
当服务器结束一个连接时,客户scokets收到一个OnDisconnect事件.当客户端结束一个连接时,服务器socket收到一个OnClientDisconnect事件.  
另外,客户端Sockets和服务器端socket从连接中收到一个错误信息时,都将产生有个错误事件.  
错误事件:客户sockets和服务器sockets通常会产生一个OnError事件,当他们从连接中收到一个错误信息的时候.你能够写一个 OnError事件处理去响应这些错误信息.这个OnError事件处理提供传送关于socket试图做什么的时候这个错误发生的信息,以及错误信息提供的错误代码.你可以在OnError事件处理中对这个错误作出响应,并且把错误代码改为0,以避免socket产生一个例外.  
当开始和完成发生时,socket控件通常会收到一个事件号(number of events).如果你的应用程序需要改变socket开始操作的处理过程或通过连接开始读或写操作时,你将写事件handlers去应答这些 client events和server events.  
A.client events  
当一个客户socket打开一个连接时,以下事件发生:  
1.一个OnLookup事件最先发生,它试图去定位server socket.在这里你不能改变Host,Address,Port,Service属性去改变你想定位的服务器.你能够使用Socket属性去访问 client windows socket object,并且使用它的SocketHandle属性去调用windows API,以便改变socket的客户属性.例如,如果你想在客户应用软件中设置端口号,你必须在server client连接前做这件事.  
2.windows socket设置和初始化事件通知.  
3. 当找到server socket时一个OnConnecting事件发生.在这事件中,windows Socket object可以利用的是通过socket属性提供关于连接的另一端的服务socket的一些信息.这是获得实际使用来连接的端口和IP地址的第一个机会,它可能不同于从监听socket处同意连接时得到的端口或IP地址.  
4.服务器同意连接请求,客户端socket完成连接.  
5.当一个连接得到确定后,一个OnConnect事件发生.如果你的socket立即开始通过连接读或写,就应写一个OnConnect事件Handler去作这件事.  
B.服务器端事件(server events)  
服务器socket控件通过两中方式连接:监听连接和连接到客户应用.服务器socket收到这两个连接的所有事件.  
监听时事件  
当构成监听连接前,OnListen事件发生.在这个时候你能够通过socket属性获得server windows socket object.你能够使用它的SocketHandle属性去改变socket,在socket打开监听之前.例如,如果你想限定监听服务使用的IP地址,你可以在这个OnListen事件Handler中做.  
与客户端连接的事件  
当一个服务器socket同意一个客户连接请求时,接下来的事件发生:  
1.服务器socket产生一个 OnGetSocket事件,通过windows socket handle传送给连接的另一端的socket.如果你想提供自己定义的TServerClientWinSocket of descendant,你可以在OnGetSocket 事件 handler中建立,将被用来替代TServerClientWinSocket.  
2.一个OnAccept事件发生,传送新的TServerClientWinSocket对象给事件句柄.这是第一个要点,当你使用TServerClientWinSocket的属性去获得被连接中服务的那端的客户的信息时.  
3.如果服务类型是stThreadBlocking,一个OnGetThread事件发生.如果你想提供自己定义的TServerClientThread子类,你可以在OnGetThread事件句柄中建立一个,它将替代TServerClientThread.  
4. 如果服务类型是stThreadBlocking,一个ONThreadStart事件发生当这个线程(thread)开始执行时.如果你想执行任何初始化这个线程,或调用一些windows socket API在这线程开始通过连接读和写之前,应该使用OnThreadStart事件句柄.  
5.当客户端完成一个连接时,一个OnClientConnect事件发生.如果是non-blocking服务,你可能想开始通过socket连接在这端进行读或写操作.  
六、通过socket连接进行读和写  
通过socket连接到其他机器的原因是想通过这些连接来读和写信息.什么信息是你要读和写的,或者当你想读和写时是依靠哪些socket连接的相关服务的.  
通过sockets进行读和写可以是异步的,所以在你的网络应用中不需要阻塞其他代码的执行.这是调用non-blocking connection.你也同样可以通过blocking connection,这时你的下一行代码的执行必须等到读或写操作完成.  
A.Non-blocking连接,读和写是异步的, 所以在你的网络应用中不需要阻塞其他代码的执行.建立一个Non-blocking连接:  
1.在客户socket中设置ClientType属性为ctNonBlocking.  
2.在服务器socket中设置ServerType属性为stNonBlocking.  
当连接是non-blocking时,连接的另一端企图读或写时读和写事件将把这个信息通知你的socket.  
读和写操作事件  
Non-blocking sockets想通过连接读或写时,它会产生一个读和写操作事件通知你的socket.在客户端sockets,你可以在OnRead或OnWrite事件句柄中对这些事件做出反应.在服务器端Scokets,可以在OnClientRead或OnClientWrite事件句柄中对这些事件做出反应.与 socket连接相关联的windows socket object在事件句柄的读或写中被当作一个参数.Windows socket object提供一个方法号(number of methods)以允许你通过连接读或写.  
通过socket连接读,使用ReceiveBuf或ReceiveText方法.在使用ReceiveBuf方法前,使用Receivelength方法去确定在连接的另一端socket准备发送的字节数(number of bytes).  
通过socket连接写,使用SendBuf,SendStream,或SendText方法.如果你通过socket发送信息后不在需要socket连接,你可以使用SendStreamThenDrop方法. SendStreamThenDrop在写完所有的信息后将关闭Socket连接,它能够从stream读信息.如果你使用SendStream或 SendStreamThenDrop方法,不要释放Stream object, socket在连接结束后会自动释放这个Stream.  
注意:SendStreamThenDrop将关闭一个独立的客户连接服务,而不是监听连接.  
B.Blocking connections  
当你使用的连接是Blocking时,你的Socket必须通过连接发起读或写操作,胜过被动的等待从socket连接发来的通知. 当你的连接末端的读和写操作发生改变时使用Blocking socket.对于客户端sockets,设置ClientType属性为ctBlocking 以便构成一个blocing connection.根据你的客户端应用想完成什么,你可能想建立一个执行线程去完成读或写操作,以便你的应用能够继续执行其他的线程,当它在等待通过连接读或写操作的完成.  
对于服务器sockets,设置ServerType属性为stThreadBlocking以便构成一个 blocking connection.因为blocking connections在等待通过连接读或写信息完成时挂起了其他代码的执行,服务器socket控件通常产生一个新的执行线程给每一个客户连接,当 ServerType设置为stThreadBlocking时.许多使用Blocking连接的应用都写使用线程(using threads.甚至如果你不使用线程,你可能也想使用(using) TWinSocketStream去读和写.  
1)using threads  
当使用一个blocking connection进行读或写操作时,客户sockets不会自动产生一个新线程.如果你的客户应用程序没有什么事做,直到读或写信息完成,那么这正是你想要的.如果你的应用包括了一个用户界面,它还需要响应用户的操作,那么,你可能想产生一个独立的线程去读写.当服务器sockets形成一个 blocking连接时,他们常常产生独立的线程给每一个客户连接,所以没有客户需要等待直到其他客户完成通过连接读或写操作.在默认情况下,服务器 sockets使用TServerClientThread对象去实现为每个连接执行不同的线程.  
TServerClientThread对象模拟发生在non-blocking连接中的OnClientRead和OnClientWrite事件.可是,这些事件发生在监听socket上时,不是本地线程(thread-local).如果客户请求频繁,你将想建立你自己的TServerClientThread子类去提供一个安全线程 (Thread-Safe)去完成读和写操作.  
当写客户线程或写服务器线程时,你能够使用TwinSocketStream去做实际的读写操作.  
A)写客户端线程  
为客户端连接写一个线程,定义一个新线程对象,使用新线程对象对话框.你的新线程对象Execute方法的句柄的通过线程连接进行读写操作的细节,可以建立一个TWinSocketStream对象,然后使用它来读或写.  
使用你自己的线程,在OnConnect事件句柄中建立它.关于建立和运行线程的更多信息,请看Executing thread objects.  
例子:这个例子显示一个应用的客户线程在连接确定后向服务器发出写请求.  
六、通过socket连接进行读和写  
通过socket连接到其他机器的原因是想通过这些连接来读和写信息.什么信息是你要读和写的,或者当你想读和写时是依靠哪些socket连接的相关服务的.  
通过sockets进行读和写可以是异步的,所以在你的网络应用中不需要阻塞其他代码的执行.这是调用non-blocking connection.你也同样可以通过blocking connection,这时你的下一行代码的执行必须等到读或写操作完成.  
A.Non-blocking连接,读和写是异步的, 所以在你的网络应用中不需要阻塞其他代码的执行.建立一个Non-blocking连接:  
1.在客户socket中设置ClientType属性为ctNonBlocking.  
2.在服务器socket中设置ServerType属性为stNonBlocking.  
当连接是non-blocking时,连接的另一端企图读或写时读和写事件将把这个信息通知你的socket.  
读和写操作事件  
Non-blocking sockets想通过连接读或写时,它会产生一个读和写操作事件通知你的socket.在客户端sockets,你可以在OnRead或OnWrite事件句柄中对这些事件做出反应.在服务器端Scokets,可以在OnClientRead或OnClientWrite事件句柄中对这些事件做出反应.与 socket连接相关联的windows socket object在事件句柄的读或写中被当作一个参数.Windows socket object提供一个方法号(number of methods)以允许你通过连接读或写.  
通过socket连接读,使用ReceiveBuf或ReceiveText方法.在使用ReceiveBuf方法前,使用Receivelength方法去确定在连接的另一端socket准备发送的字节数(number of bytes).  
通过socket连接写,使用SendBuf,SendStream,或SendText方法.如果你通过socket发送信息后不在需要socket连接,你可以使用SendStreamThenDrop方法. SendStreamThenDrop在写完所有的信息后将关闭Socket连接,它能够从stream读信息.如果你使用SendStream或 SendStreamThenDrop方法,不要释放Stream object, socket在连接结束后会自动释放这个Stream.  
注意:SendStreamThenDrop将关闭一个独立的客户连接服务,而不是监听连接.  
B.Blocking connections  
当你使用的连接是Blocking时,你的Socket必须通过连接发起读或写操作,胜过被动的等待从socket连接发来的通知. 当你的连接末端的读和写操作发生改变时使用Blocking socket.对于客户端sockets,设置ClientType属性为ctBlocking 以便构成一个blocing connection.根据你的客户端应用想完成什么,你可能想建立一个执行线程去完成读或写操作,以便你的应用能够继续执行其他的线程,当它在等待通过连接读或写操作的完成.  
对于服务器sockets,设置ServerType属性为stThreadBlocking以便构成一个 blocking connection.因为blocking connections在等待通过连接读或写信息完成时挂起了其他代码的执行,服务器socket控件通常产生一个新的执行线程给每一个客户连接,当 ServerType设置为stThreadBlocking时.许多使用Blocking连接的应用都写使用线程(using threads.甚至如果你不使用线程,你可能也想使用(using) TWinSocketStream去读和写.  
1)using threads  
当使用一个blocking connection进行读或写操作时,客户sockets不会自动产生一个新线程.如果你的客户应用程序没有什么事做,直到读或写信息完成,那么这正是你想要的.如果你的应用包括了一个用户界面,它还需要响应用户的操作,那么,你可能想产生一个独立的线程去读写.当服务器sockets形成一个 blocking连接时,他们常常产生独立的线程给每一个客户连接,所以没有客户需要等待直到其他客户完成通过连接读或写操作.在默认情况下,服务器 sockets使用TServerClientThread对象去实现为每个连接执行不同的线程.  
TServerClientThread对象模拟发生在non-blocking连接中的OnClientRead和OnClientWrite事件.可是,这些事件发生在监听socket上时,不是本地线程(thread-local).如果客户请求频繁,你将想建立你自己的TServerClientThread子类去提供一个安全线程 (Thread-Safe)去完成读和写操作.  
当写客户线程或写服务器线程时,你能够使用TwinSocketStream去做实际的读写操作.  
A)写客户端线程  
为客户端连接写一个线程,定义一个新线程对象,使用新线程对象对话框.你的新线程对象Execute方法的句柄的通过线程连接进行读写操作的细节,可以建立一个TWinSocketStream对象,然后使用它来读或写.  
使用你自己的线程,在OnConnect事件句柄中建立它.关于建立和运行线程的更多信息,请看Executing thread objects.  
例子:这个例子显示一个应用的客户线程在连接确定后向服务器发出写请求.  
void __fastcall TMyClientThread::Execute()  
{  
while (!Terminated && ClientSocket1->Active)  
// make sure connection is active  
{  
try  
{  
TWinSocketStream *pStream = new TWinSocketStream(ClientSocket1.Socket,60000);  
try  
{  
char buffer[10];  
GetNextRequest(buffer);  
// GetNextRequest must be a thread-safe method  
// write a request to the server  
pStream->Write(buffer,strlen(buffer) + 1);  
// continue the communication (eg read a response)  
}  
__finally  
{  
delete pStream;  
}  
}  
catch (Exception &E)  
{  
if (!E.ClassNameIs("EAbort"))  
Synchronize(HandleThreadException());  
// you must write HandleThreadException  
}  
}  
}  
B)写服务器线程  
服务器连接线程由TServerClientThread派生.因为这个,不能使用新线程对象对话框.替代的,手动声明你的线程如下:  
class PACKAGE TMyServerThread :  
public ScktComp::TServerClientThread  
{  
public  
void __fastcall ClientExecute(void);  
}  
注意你将用重载ClientExcute方法替代Execute方法.执行ClientExecute方法必须为客户端连接写一个同样的 Execute方法线程.然而,当你从控件栏上放一个客户socket控件到你的应用上时来替代这个方法时.监听服务socket同意一个连接时,服务客户线程必须使用TServerClientWinSocket对象来建立.这可以利用共公共的CientSocket属性.另外,你能够使用 HandleException这个protected性的方法,胜过  
你自己写你的thread-safe例外操作.  
警告:Server sockets会缓存他们使用到的线程.确信ClientExecute方法执行一些必要的初始化操作,以便它们在最后执行时不致于产生不利的结果.  
当你使用你的线程时,在OnGetThread事件句柄中建立它.当建立线程,设置CreateSuspended参数为false.  
例子:这个例子显示一个为一个应用服务的线程,这个应用是在连接确定后由客户端来的读请求.  
void __fastcall TMyServerThread::ClientExecute()  
{  
while (!Terminated && ClientSocket->Connected)  
// make sure connection is active  
{  
try  
{  
TWinSocketStream *pStream = new TWinSocketStream(ClientSocket,  
60000);  
try  
{  
char buffer[10];  
memset(buffer, 0, sizeof(buffer));  
if (pStream->WaitForData(60000))  
// give the client 60 seconds to start writing  
{  
if (pStream->Read(buffer, sizeof(buffer) == 0)  
ClientSocket->Close();  
// if can’t read in 60 seconds, close the connection  
// now process the request  
}  
else  
ClientSocket->Close();  
}  
__finally  
{  
delete pStream;  
}  
}  
catch (…)  
{  
HandleException();  
}  
}  
}  
C.使用TwinSocketStream  
当为一个blocking连接实现一个线程时,你必须确定在连接的另一端的socket是准备写还是读.Blocking连接不会通知socket当它准备好写或读操作的时候.想看看连接是否准备好,使用TWinSocketStream对象.TWinSocketStream提供一个方法去帮助调整读或写操作时间的选择.调用WaitForData方法去等待,直到socket另一端的  
准备好写操作.当读写操作使用TWinSocketStream时,如果读或写操作在指定的时间期限内未能完成,Stream将发生超时.这个超时被当作一个结果,socket应用不会暂停,而是不断的通过一个dropped connection试图读或写.  
注意:你不能在non-blocking连接中使用TWinSocketStream